/**
 * File Watcher Service
 *
 * Monitors the results folder for detection_*.json and forecast_*.json files
 * that are automatically generated by external ML processes.
 *
 * NOTE: This service does NOT trigger ML processing or video analysis.
 * It passively monitors and serves result files created by external systems.
 *
 * Provides real-time updates when new files are created or modified by external ML processes.
 *
 * Usage:
 * - Call startWatching() to begin monitoring
 * - Listen to 'fileChanged' events for updates
 * - Call getAvailableFiles() to get current file list
 * - Call getFileContents() to read specific files
 */

const fs = require("fs");
const path = require("path");
const EventEmitter = require("events");

class FileWatcherService extends EventEmitter {
  constructor() {
    super();
    // Use absolute path to results folder
    this.resultsPath = path.resolve(process.cwd(), "../../results");
    this.watcher = null;
    this.fileCache = new Map();
    this.isWatching = false;

    console.log(`FileWatcher monitoring: ${this.resultsPath}`);

    // Ensure results directory exists
    if (!fs.existsSync(this.resultsPath)) {
      console.log(`Creating results directory: ${this.resultsPath}`);
      fs.mkdirSync(this.resultsPath, { recursive: true });
    } else {
      console.log(`Results directory found: ${this.resultsPath}`);
      // Scan and cache existing files
      this.scanDirectory();
    }
  }

  /**
   * Start watching the results folder for changes
   */
  startWatching() {
    if (this.isWatching) {
      console.log("File watcher already running");
      return;
    }

    try {
      this.watcher = fs.watch(
        this.resultsPath,
        { persistent: true },
        (eventType, filename) => {
          if (filename && this.isValidFile(filename)) {
            this.handleFileChange(eventType, filename);
          }
        }
      );

      this.isWatching = true;
      console.log(
        `[IMPORTANT] File watcher started - monitoring: ${this.resultsPath}`
      );

      // Initial scan of existing files
      this.scanExistingFiles();
    } catch (error) {
      console.error("Error starting file watcher:", error);
    }
  }

  /**
   * Stop watching the results folder
   */
  stopWatching() {
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
      this.isWatching = false;
      console.log("[IMPORTANT] File watcher stopped");
    }
  }

  /**
   * Scan directory and populate cache with existing files
   */
  scanDirectory() {
    try {
      const files = fs.readdirSync(this.resultsPath);
      let processedCount = 0;

      files.forEach((filename) => {
        if (this.isValidFile(filename)) {
          this.processFile(filename);
          processedCount++;
        }
      });

      console.log(`Scanned and cached ${processedCount} existing files`);
    } catch (error) {
      console.error("Error scanning directory:", error);
    }
  }

  /**
   * Check if a filename matches our patterns
   */
  isValidFile(filename) {
    return !!(
      filename.match(/^(detections|forecast)_.*\.json$/) ||
      filename === "detections.json" ||
      filename === "forecast.json"
    );
  }

  /**
   * Process a single file and add to cache
   */
  processFile(filename) {
    try {
      const fileInfo = this.getFileInfo(filename);
      if (fileInfo) {
        this.fileCache.set(filename, fileInfo);
      }
    } catch (error) {
      console.error(`Error processing file ${filename}:`, error);
    }
  }

  /**
   * Handle file system changes
   */
  handleFileChange(eventType, filename) {
    const filePath = path.join(this.resultsPath, filename);

    if (eventType === "rename") {
      // File was created or deleted
      if (fs.existsSync(filePath)) {
        this.handleFileCreated(filename);
      } else {
        this.handleFileDeleted(filename);
      }
    } else if (eventType === "change") {
      // File was modified
      this.handleFileModified(filename);
    }
  }

  /**
   * Handle new file creation
   */
  handleFileCreated(filename) {
    console.log(`[IMPORTANT] New file detected: ${filename}`);
    const fileInfo = this.getFileInfo(filename);

    if (fileInfo) {
      this.fileCache.set(filename, fileInfo);
      this.emit("fileChanged", {
        type: "created",
        filename,
        fileInfo,
      });
    }
  }

  /**
   * Handle file deletion
   */
  handleFileDeleted(filename) {
    console.log(`[IMPORTANT] File deleted: ${filename}`);
    this.fileCache.delete(filename);
    this.emit("fileChanged", {
      type: "deleted",
      filename,
    });
  }

  /**
   * Handle file modification
   */
  handleFileModified(filename) {
    console.log(`[IMPORTANT] File modified: ${filename}`);
    const fileInfo = this.getFileInfo(filename);

    if (fileInfo) {
      this.fileCache.set(filename, fileInfo);
      this.emit("fileChanged", {
        type: "modified",
        filename,
        fileInfo,
      });
    }
  }

  /**
   * Scan existing files in the results directory
   */
  scanExistingFiles() {
    try {
      const files = fs.readdirSync(this.resultsPath);
      const validFiles = files.filter((file) => this.isValidFile(file));

      console.log(
        `[IMPORTANT] Found ${validFiles.length} existing result files`
      );

      validFiles.forEach((filename) => {
        const fileInfo = this.getFileInfo(filename);
        if (fileInfo) {
          this.fileCache.set(filename, fileInfo);
        }
      });
    } catch (error) {
      console.error("Error scanning existing files:", error);
    }
  }

  /**
   * Get metadata for a specific file
   */
  getFileInfo(filename) {
    const filePath = path.join(this.resultsPath, filename);

    try {
      const stats = fs.statSync(filePath);
      const type = filename.startsWith("detection") ? "detection" : "forecast";

      // Extract frame number from filename if present
      const frameMatch = filename.match(/_(\d+)\.json$/);
      const frameNumber = frameMatch ? parseInt(frameMatch[1]) : null;

      return {
        filename,
        type,
        frameNumber,
        size: stats.size,
        created: stats.birthtime,
        modified: stats.mtime,
        path: filePath,
      };
    } catch (error) {
      console.error(`Error getting file info for ${filename}:`, error);
      return null;
    }
  }

  /**
   * Get list of all available files with metadata
   */
  getAvailableFiles() {
    const files = Array.from(this.fileCache.values());

    // Sort by type, then by frame number or modification time
    files.sort((a, b) => {
      if (a.type !== b.type) {
        return a.type.localeCompare(b.type);
      }

      if (a.frameNumber !== null && b.frameNumber !== null) {
        return a.frameNumber - b.frameNumber;
      }

      return new Date(b.modified) - new Date(a.modified);
    });

    return files;
  }

  /**
   * Get contents of a specific file
   */
  async getFileContents(filename) {
    const filePath = path.join(this.resultsPath, filename);

    try {
      const content = await fs.promises.readFile(filePath, "utf8");
      const data = JSON.parse(content);

      return {
        filename,
        data,
        metadata: this.fileCache.get(filename) || this.getFileInfo(filename),
      };
    } catch (error) {
      console.error(`Error reading file ${filename}:`, error);
      throw new Error(`Failed to read file: ${filename}`);
    }
  }

  /**
   * Check if the file watcher is active
   */
  get isActive() {
    return this.isWatching && this.watcher !== null;
  }

  /**
   * Get the latest file of a specific type
   */
  getLatestFile(type) {
    const files = this.getAvailableFiles().filter((file) => file.type === type);

    if (files.length === 0) {
      return null;
    }

    // Return the file with the highest frame number or most recent modification
    return files.reduce((latest, current) => {
      if (current.frameNumber !== null && latest.frameNumber !== null) {
        return current.frameNumber > latest.frameNumber ? current : latest;
      }
      return new Date(current.modified) > new Date(latest.modified)
        ? current
        : latest;
    });
  }

  /**
   * Clean up old files (optional utility method)
   */
  cleanupOldFiles(maxFiles = 50) {
    const files = this.getAvailableFiles();

    if (files.length <= maxFiles) {
      return;
    }

    // Group by type
    const detectionFiles = files.filter((f) => f.type === "detection");
    const forecastFiles = files.filter((f) => f.type === "forecast");

    // Keep only the most recent files of each type
    const filesToDelete = [
      ...detectionFiles.slice(0, -Math.floor(maxFiles / 2)),
      ...forecastFiles.slice(0, -Math.floor(maxFiles / 2)),
    ];

    filesToDelete.forEach((file) => {
      try {
        fs.unlinkSync(file.path);
        console.log(`[IMPORTANT] Cleaned up old file: ${file.filename}`);
      } catch (error) {
        console.error(`Error deleting file ${file.filename}:`, error);
      }
    });
  }
}

// Export the class and create singleton instance
module.exports = FileWatcherService;
module.exports.instance = new FileWatcherService();
