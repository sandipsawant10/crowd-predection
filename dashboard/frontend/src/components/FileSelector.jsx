/**
 * FileSelector Component
 *
 * Allows users to browse and select detection/forecast files that are
 * automatically generated by external ML processes.
 *
 * NOTE: This component does NOT trigger ML processing. It only displays
 * and allows selection of result files created by external systems.
 *
 * Supports real-time updates when new files are detected in the results folder.
 */

import React, { useState, useEffect } from "react";
import {
  Box,
  Card,
  CardContent,
  Typography,
  List,
  ListItem,
  ListItemButton,
  ListItemText,
  ListItemIcon,
  Chip,
  Divider,
  CircularProgress,
  Alert,
  Tabs,
  Tab,
  IconButton,
  Tooltip,
  LinearProgress,
} from "@mui/material";
import {
  Assessment as DetectionIcon,
  TrendingUp as ForecastIcon,
  Refresh as RefreshIcon,
  PlayArrow as PlayIcon,
  GetApp as DownloadIcon,
  Schedule as TimeIcon,
} from "@mui/icons-material";
import { format } from "date-fns";
import { resultAPI } from "../utils/api";

const FileSelector = ({ onFileSelect, selectedFile, autoRefresh = true }) => {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState(0);
  const [stats, setStats] = useState(null);
  const [refreshing, setRefreshing] = useState(false);

  // Filter files by type based on active tab
  const filteredFiles = files.filter((file) => {
    if (activeTab === 0) return true; // All files
    if (activeTab === 1) return file.type === "detection";
    if (activeTab === 2) return file.type === "forecast";
    return false;
  });

  // Load files from API with fallback to demo data
  const loadFiles = async (showLoading = true) => {
    try {
      if (showLoading) setLoading(true);
      setRefreshing(!showLoading);
      setError(null);

      // Try to get data from API
      try {
        const [filesResponse, statsResponse] = await Promise.all([
          resultAPI.getFiles(),
          resultAPI.getStats(),
        ]);

        if (filesResponse.success) {
          setFiles(filesResponse.files);
        }

        if (statsResponse.success) {
          setStats(statsResponse.stats);
        }
      } catch (apiError) {
        console.warn("API unavailable, using fallback data:", apiError);

        // Fallback to simulated file list based on known files
        const mockFiles = [
          {
            filename: "detections_60.json",
            type: "detection",
            modified: new Date().toISOString(),
            sizeFormatted: "2.4 KB",
            frameNumber: 60,
          },
          {
            filename: "forecast_60.json",
            type: "forecast",
            modified: new Date().toISOString(),
            sizeFormatted: "1.2 KB",
          },
          {
            filename: "detections_30.json",
            type: "detection",
            modified: new Date(Date.now() - 300000).toISOString(),
            sizeFormatted: "2.1 KB",
            frameNumber: 30,
          },
          {
            filename: "forecast_30.json",
            type: "forecast",
            modified: new Date(Date.now() - 300000).toISOString(),
            sizeFormatted: "1.1 KB",
          },
        ];

        setFiles(mockFiles);
        setStats({
          total: mockFiles.length,
          detectionFiles: mockFiles.filter((f) => f.type === "detection")
            .length,
          forecastFiles: mockFiles.filter((f) => f.type === "forecast").length,
          totalSizeFormatted: "6.8 KB",
        });

        setError("Using offline mode - API unavailable");
      }
    } catch (err) {
      console.error("Error loading files:", err);
      setError("Failed to load result files. Please try again.");
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  // Handle file selection
  const handleFileSelect = (file) => {
    onFileSelect(file);
  };

  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };

  // Handle manual refresh
  const handleRefresh = () => {
    loadFiles(false);
  };

  // Download file contents
  const handleDownload = async (file, event) => {
    event.stopPropagation();

    try {
      const response = await resultAPI.getFileContents(file.filename);

      if (response.success) {
        const dataStr = JSON.stringify(response.data, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });

        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement("a");
        link.href = url;
        link.download = file.filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }
    } catch (err) {
      console.warn("Download not available in offline mode:", err);
      alert(
        "File download is not available when API is offline. Please try again later."
      );
    }
  };

  // Format file size
  const formatFileSize = (bytes) => {
    if (bytes === 0) return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  };

  // Format timestamp
  const formatTime = (timestamp) => {
    try {
      return format(new Date(timestamp), "MMM dd, HH:mm:ss");
    } catch {
      return "Unknown";
    }
  };

  // Get file icon
  const getFileIcon = (type) => {
    return type === "detection" ? <DetectionIcon /> : <ForecastIcon />;
  };

  // Get file color
  const getFileColor = (type) => {
    return type === "detection" ? "primary" : "secondary";
  };

  // Initial load
  useEffect(() => {
    loadFiles();
  }, []);

  // Auto-refresh setup
  useEffect(() => {
    if (!autoRefresh) return;

    const interval = setInterval(() => {
      loadFiles(false);
    }, 10000); // Refresh every 10 seconds

    return () => clearInterval(interval);
  }, [autoRefresh]);

  if (loading) {
    return (
      <Card>
        <CardContent>
          <Box
            display="flex"
            alignItems="center"
            justifyContent="center"
            py={4}
          >
            <CircularProgress />
            <Typography variant="body2" sx={{ ml: 2 }}>
              Loading result files...
            </Typography>
          </Box>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardContent>
        {/* Header */}
        <Box
          display="flex"
          justifyContent="space-between"
          alignItems="center"
          mb={2}
        >
          <Typography variant="h6" component="h2">
            Result Files
          </Typography>
          <Tooltip title="Refresh file list">
            <IconButton onClick={handleRefresh} disabled={refreshing}>
              <RefreshIcon />
            </IconButton>
          </Tooltip>
        </Box>

        {/* Stats */}
        {stats && (
          <Box mb={2}>
            <Typography variant="body2" color="text.secondary">
              {stats.total} files ({stats.detectionFiles} detection,{" "}
              {stats.forecastFiles} forecast) • {stats.totalSizeFormatted}
            </Typography>
          </Box>
        )}

        {refreshing && <LinearProgress sx={{ mb: 2 }} />}

        {/* Error Alert */}
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        {/* Tabs */}
        <Box sx={{ borderBottom: 1, borderColor: "divider", mb: 2 }}>
          <Tabs value={activeTab} onChange={handleTabChange}>
            <Tab label={`All (${files.length})`} />
            <Tab
              label={`Detection (${
                files.filter((f) => f.type === "detection").length
              })`}
            />
            <Tab
              label={`Forecast (${
                files.filter((f) => f.type === "forecast").length
              })`}
            />
          </Tabs>
        </Box>

        {/* File List */}
        {filteredFiles.length === 0 ? (
          <Box textAlign="center" py={4}>
            <Typography variant="body2" color="text.secondary">
              No files found
            </Typography>
          </Box>
        ) : (
          <List sx={{ maxHeight: 400, overflow: "auto" }}>
            {filteredFiles.map((file, index) => (
              <React.Fragment key={file.filename}>
                <ListItem disablePadding>
                  <ListItemButton
                    onClick={() => handleFileSelect(file)}
                    selected={selectedFile?.filename === file.filename}
                  >
                    <ListItemIcon>{getFileIcon(file.type)}</ListItemIcon>

                    <ListItemText
                      primary={
                        <Box display="flex" alignItems="center" gap={1}>
                          <Typography variant="body2" component="span">
                            {file.filename}
                          </Typography>
                          <Chip
                            label={file.type}
                            size="small"
                            color={getFileColor(file.type)}
                          />
                          {file.frameNumber && (
                            <Chip
                              label={`Frame ${file.frameNumber}`}
                              size="small"
                              variant="outlined"
                            />
                          )}
                        </Box>
                      }
                      secondary={
                        <Box
                          display="flex"
                          alignItems="center"
                          gap={2}
                          mt={0.5}
                        >
                          <Box display="flex" alignItems="center" gap={0.5}>
                            <TimeIcon fontSize="small" />
                            <Typography variant="caption" component="span">
                              {formatTime(file.modified)}
                            </Typography>
                          </Box>
                          <Typography
                            variant="caption"
                            color="text.secondary"
                            component="span"
                          >
                            {file.sizeFormatted}
                          </Typography>
                        </Box>
                      }
                      primaryTypographyProps={{ component: "div" }}
                      secondaryTypographyProps={{ component: "div" }}
                    />

                    <Tooltip title="Download file">
                      <IconButton
                        size="small"
                        onClick={(e) => handleDownload(file, e)}
                      >
                        <DownloadIcon fontSize="small" />
                      </IconButton>
                    </Tooltip>
                  </ListItemButton>
                </ListItem>
                {index < filteredFiles.length - 1 && <Divider />}
              </React.Fragment>
            ))}
          </List>
        )}

        {/* Footer */}
        <Box mt={2} pt={2} borderTop={1} borderColor="divider">
          <Typography variant="caption" color="text.secondary">
            Auto-refreshing every 10 seconds • Last updated:{" "}
            {new Date().toLocaleTimeString()}
          </Typography>
        </Box>
      </CardContent>
    </Card>
  );
};

export default FileSelector;
